---
typora-root-url: assets
---

# 第一章 多任务编程-进程 (第三阶段)

# 一.多任务的介绍

> 提问:利用现在学的知识,能让两个函数或者方法同时执行吗?
>
> 不能,之前所写的程序都是单任务的,也就是说一个函数或者方法执行完成另外一个函数或者方法才能执行,想要实现这种操作就需要使用多任务.
>
> - 实际工作中大多会使用一些工具来实现
>
> 多任务的优点?
>
> 充分利用Cpu资源,提高执行程序的效率

## 1.多任务的概念

多任务指的是同一时间执行多个任务

## 2.多任务执行方式

- **并发**
  - 对于单核CPU
  - 一段时间内去交替执行任务
- **并行**
  - 对于多核cpu处理多任务
  - 操作系统会给每个内核安排一个执行的软件,多核是真正的一起执行软件
  - 多核cpu是并行执行任务,始终有多个软件一起执行
  - 如果任务多于核心数量,还是会转换为并发

> 现在电脑单个cpu可以达到2核/4核/8核
>
> 对于服务器单个cpu可以达到32核

# 二.进程

## 1.进程介绍

- 在Python程序中,想要实现多任务可以使用进程来完成 , **进程是实现多任务的一种方式**

## 2.进程的概念

- ``进程是操作系统进行资源分配的基本单位``
- 一个运行的的程序或者软件至少有一个进程 , 每启动一个进程,操作系统都会给其分配一定的运行资源(内存资源),保证进程的运行
- 一个程序运行之后至少有一个进程,一个进程默认有一个线程 , 进程里面可以创建多个线程,线程是依附在进程里面的 , 没有进程就没有线程

# 三.多进程的使用

## 1.导入进程包

```python
import multiprocessing
```

## 2.Process进程类的说明

```python
# self
# 指定分组 group=None,
# 指定要调用的函数名 target=None,
# 指定进程名称 name=None,
# 给函数传递参数 args=(), kwargs={},*,
# 指定守护进程 daemon=None
```
## 3.多进程的基本使用

```python
# 进程的使用
# 导入多进程模块
import multiprocessing


def login():
    print('登录')


def pwd():
    print('请输入密码')


if __name__ == '__main__':

    # 若想多次调用函数,可以在一个进程内进行多次调用,也可以使用多进程完成多次调用
    # self
    # 指定分组 group=None,
    # 指定要调用的函数名 target=None,
    # 指定进程名称 name=None,
    # 给函数传递参数 args=(), kwargs={},*,
    # 指定守护进程 daemon=None

    # 创建多个进程(指定不同的函数)
    p1 = multiprocessing.Process(target=login())
    p2 = multiprocessing.Process(target=pwd())

# 运行进程指定对应函数业务逻辑
# start()方法可以进行进程的运行
    p1.start()    # 登录
    p2.start()    # 请输入密码

# 疑问:为什么可以多次调用,还要创建多个进程?
# 多任务执行和一个任务多次执行,多任务的执行速度更快
```

## 4.进程使用的一些注意事项

① `	p1 = multiprocessing.Process(target=login())`

- Process : 一定要P大写 , 否则报错

②多进程放到mian()里面 , 否则会无限循环执行进程,报错

- 创建多个进程执行的时候 , 运行进程对象即指定对应函数 , 就相当于是导包过程
- 如果不加`if __name__ == '__main__':`则会报错,循环调用

③进程的执行顺序是CPU决定的 , 随机的

- 一般不这样用

- 若想使进程同步按照顺序执行,需要用到join方法(等待)

- ```python
  p1.start()
  p2.start()
  ```

## 5.进程传参

- args传参使用元组
  - 元组中的元素顺序一定要和参数的顺序保持一致
- kwargs传参使用字典传入
  - 字典中的key值一定要和参数名保持一致

```python
import multiprocessing

def login(name, password):
    print('登录')
    print(f'账号名为:{name}')
    print(f'请输入密码:{password}')
    
if __name__ == '__main__':   
    
    p1 = multiprocessing.Process(target=login, args=('Python', 123456))
    p2 = multiprocessing.Process(target=login, kwargs={'name': 'Php', 'password':'123456'})

# 运行进程指定对应函数业务逻辑
    p1.start()    
    p2.start()    
'''
登录
账号名为:Python
请输入密码:123456
登录
账号名为:Php
请输入密码:123456'''
```

## 6.进程名称指定

- 可以区分进程是谁
- 也可以看出进程的顺序

```python
# 获取当前进程名称, 使用current_process()方法
print('进程名称为:', multiprocessing.current_process().name)
```

```python
def login(name, password):
    print('登录')
    print(f'账号名为:{name}')
    print(f'请输入密码:{password}')
    # 获取当前进程名称
    print('进程名称为:', multiprocessing.current_process().name)
    
if __name__ == '__main__':
    p1 = multiprocessing.Process(target=login, args=('Python', 123456), name='p1')
    p2 = multiprocessing.Process(target=login, kwargs={'name': 'Php', 'password':'123456'}, name='p2')
    p1.start()
    p2.start()
    
 '''
 登录
账号名为:Python
请输入密码:123456
进程名称为: p1
 '''
```

## 7.获取进程编号

### ①导入os模块

```python
# 导入os模块
import os
```

### ②获取进程编号

> 获取进程编号的目的是:验证主进程和子进程的关系,可以得知子进程是由哪个主进程创建出来的

- 主进程 : 整个文件是一个主进程 ----os.getppid()
- 子进程:在文件中创建的进程是主进程的子进程 ----os.getpid()

- 子进程依赖主进程
- 子进程的所有操作都可以归主进程进行管理

```python
# 导入多进程模块
import multiprocessing
# 导入os模块
import os

def login(name, password):
    print('登录')
    print(f'账号名为:{name}')
    print(f'请输入密码:{password}')
    # 获取当前进程名称
    print('进程名称为:', multiprocessing.current_process().name)
    # 获取进程编号
    print('子进程编号为:', os.getpid())
    # 获取子进程的父进程
    print('子进程的父进程编号为', os.getppid())
    
if __name__ == '__main__':
    p1 = multiprocessing.Process(target=login, args=('Python', 123456), name='p1')
    p2 = multiprocessing.Process(target=login, kwargs={'name': 'Php', 'password': '123456'}, name='p2')

    # 运行进程指定对应函数业务逻辑
    p1.start()
    p2.start()

'''
登录
账号名为:Python
请输入密码:123456
进程名称为: p1
子进程编号为: 123428
登录
账号名为:Php
请输入密码:123456
进程名称为: p2
子进程编号为: 124828
子进程的父进程编号为 123692
子进程的父进程编号为 123692
'''
```

# 四.进程的注意点

## 1.进程之间不共享全局变量

- 当多个进程都指向同一个函数时 , 各个进程之间是独立的
- 并且进程之间不共享全局变量
- 主进程和子进程之间也是独立的

```python
# Process（target=函数名，args=（），name,kwargs）
# target:加进程调用的函数名，一般不加括号
# 加了括号,target接受到的就是函数的返回值??
# 不接括号,target接受到的就是函数本身
# name：进程的名字
# kwargs：字典参数
```
```python
import multiprocessing

# 不共享全局变量
data_list = []

def write_data():

    # 往全局列表中写数据:
    for i in range(0, 5):
        data_list.append(i)
    print('write_data方法写入的数据为:', data_list)
    # return 这里返回函数本身是不是就死循环了???


def read_data():
    print('read_data方法读取的数据为:', data_list)


if __name__ == '__main__':
    # 创建多进程,分别调用两个读写方法,验证全局变量是否共享数据
    p1 = multiprocessing.Process(target=write_data)   # 一定不能加()
    # p1 = Process(target=write_data())
    p2 = multiprocessing.Process(target=read_data)   # target后面的函数名后一定不能加()
    # p2 = Process(target=write_data())

    p1.start()
    p2.start()
    print(data_list)

'''    
[]
read_data方法读取的数据为: []
write_data方法写入的数据为: [0, 1, 2, 3, 4]    
'''  
```

## 2.主进程会等待所有的子进程执行结束后在结束

```python
p1.start()
p2.start()
exit()
print(data_list)

'''    
read_data方法读取的数据为: []
write_data方法写入的数据为: [0, 1, 2, 3, 4]    
'''  
```

![1647241351465](/1647241351465.png)

## 3.守护进程

> 需求:主进程结束后就结束子进程 , 不再等待
>
> ①设置守护进程 
>
> - ```
>   子进程对象名.daemon = True
>   ```
>
> - daemon=True
>
> ②主动关闭子进程 : 子进程对象.terminate

```python
if __name__ == '__main__':
    # 创建多进程,分别调用两个读写方法,验证全局变量是否共享数据
    p1 = multiprocessing.Process(target=write_data, daemon=True)   # 一定不能加()
    p2 = multiprocessing.Process(target=read_data)   # target后面的函数名后一定不能加()


    p1.start()
    p2.start()
    print(data_list)
    p2.termination
    
    
# []
```
# 五.进程间数据共享

> 进程之间怎么进行数据共享?
>
> 借助于介质
>
> - 文件
>
> - 数据库
>
>   - redis(数据存储在内存)
>
> - > 在内存上读数据要比磁盘上快的多
>   >
>   > - 磁盘需要进行打开关闭I/O操作

```python
import multiprocessing

# 不共享全局变量
data_list = []


def write_data():
    for i in range(0, 5):
        data_list.append(i)
    print('write_data方法写入的数据为:', data_list)
    # 将数据写入文件
    file = open('a.txt', 'w')
    file.write(str(data_list))
    file.close()


def read_data():
    file = open('a.txt', 'r')
    data = file.read()
    file.close()
    print('read_data方法读取的数据为:', data)


if __name__ == '__main__':
    p1 = multiprocessing.Process(target=write_data)
    p2 = multiprocessing.Process(target=read_data)
    p1.start()
    p1.join()
    p2.start()
    p2.join()
    print(data_list)
```

