---
typora-root-url: assets
---

# 第九章 正则表达式

# 一.with语句 

## 1.with作用

实现文件读写,无论是否读写成功都会帮助关闭文件

## 2.with语句的使用

```python
file = open('1.txt', 'w')
file.write("hello world")
# 当前两步执行的时候出错,文件就不会被关闭
# with可以解决这个问题,try except也可以
file.close()
```

```python
file = open('1.txt', 'wb')
try:
    file.write("hello world")
except:
    print('文件写入错误')
finally:
    file.close()  # 文件写入错误
```

```python
# with 实现文件读写,无论是否读写成功都会帮助关闭文件
with open('a.log', 'r') as file:
    data = file.read()

print(data)  # division by zero 
```

# 二.深拷贝和浅拷贝

> 变量数据复制的时候会用到深浅拷贝

## 1.浅拷贝

![1647780841365](/1647780841365.png)

### ①不可变类型数据

对于不可变类型 : 浅拷贝没有任何应影响,变量地址都不变

```python
# 不可变类型数据的深浅拷贝
# 数值型,字符串,元组
a = 10
b = 'python'
print(id(a))
print(id(b))

# 数据浅拷贝
import copy
copy_a = copy.copy(a)
copy_b = copy.copy(b)
print('-'*20)
print(id(copy_a))
print(id(copy_b))

140703412639680
2232587995440
--------------------
140703412639680
2232587995440
```

### ②可变类型数据

对于可变类型:浅拷贝新开辟了一块内存地址,然后复制原始数据放入新地址

```python
c = [1, 2, 3, 'a', 'b', 'c']
d = {1: 1, 'name': 'python', 'a_list': [1, 2, 3, 4]}
print(id(c))
print(id(d))

import copy
copy_c = copy.copy(c)
copy_d = copy.copy(d)
print('-'*20)
print(id(copy_c))
print(id(copy_d))

# 1434312494784
# 1434312440512
# --------------------
# 1434312856896
# 1434312440576
```

![1647779512012](/1647779512012.png)

### ③修改浅拷贝后的可变类型数据

> 对于可变类型数据:
>
> 修改浅拷贝后的数据 , 如果数据里面有嵌套的数据,则会直接改变到原数据

```python
copy_c[3] = 'aaaa'
print(copy_c)
print(c)
# [1, 2, 3, 'aaaa', 'b', 'c']
# [1, 2, 3, 'a', 'b', 'c']
copy_d['a_list'][0] = 'aa'
print(copy_d)
print(d)
# {1: 1, 'name': 'python', 'a_list': ['aa', 2, 3, 4]}
# {1: 1, 'name': 'python', 'a_list': ['aa', 2, 3, 4]}
```

## 2. 深拷贝

### ①不可变类型

> 没有任何影响 , 都指向原数据地址

### ②可变类型

> - 解决浅拷贝数据嵌套修改问题, 使变量独立
> - 深拷贝也是创建了新空间

```python
import copy
c = [1, 2, 3, 'a', 'b', 'c']
d = {1: 1, 'name': 'python', 'a_list': [1, 2, 3, 4]}
print(id(d))
print('-'*20)
deepcopy_d = copy.deepcopy(d)
print(id(deepcopy_d))
deepcopy_d['a_list'][0] = 'bbb'
print('-'*20)
print(deepcopy_d)
print(d)
# 2689222703872
# --------------------
# 2689252084800
# --------------------
# {1: 1, 'name': 'python', 'a_list': ['bbb', 2, 3, 4]}
# {1: 1, 'name': 'python', 'a_list': [1, 2, 3, 4]}
```

## 3.深浅拷贝应用场景

### ①类中多个函数用同一个变量

> 需要保证变量的独立性
>
> 在进行独立数据的操作的时候 , 不想影响原始数据,那么就使用深拷贝

```python
# 场景1
import copy


class A():
    def __init__(self):
        self.url = None

    def func1(self):
        self.url = [1, 2, 3, 4, 'a', ['Jack', 'lily']]
        self.url[5][0] = 'Bob'

    def func2(self):
        # func2函数也要对自己的url进行操作
        # 如果进行浅拷贝,那么func1中的修改操作就会影响
        # 因此这种情况用深拷贝
        self.func2_url = copy.deepcopy(self.url)
```

### ②爬虫

```python
import copy

# 当爬取过一个地址之后就要删除这个,防止重复爬取
# 那么肯定是不能直接删原数据的,因此需要拷贝一份,在自己的函数内部,删除拷贝的那一份
class A():
    def __init__(self):
        self.url = {'baidu': ['http://www.baidu.com/login', 'http://www.baidu.com/register'], 'jd': []}

    def func1(self):
        # 爬取百度
        self.copy_url = copy.deepcopy(self.url)
        self.baidu_url = self.url['baidu']
        print(self.baidu_url)

    def func2(self):
        # 爬取京东
        self.jd_url = self.url['baidu']
        print(self.jd_url)
```

## 4.总结

- 对于不可变类型
  - 用=/浅拷贝/深拷贝 : 效果都一样,都是指向原数据地址
  - 因此用哪个都可以
- 对于可变类型
  - 对于有嵌套的数据 , 建议用深拷贝
  - 如果不知道什么时侯用 , 对于可变类型 , 都用深拷贝

# 三.正则表达式

## 1.正则表达式介绍

### ①应用场景

- 在实际开发过程中经常会有查找某些复杂规则的字符串的需要,比如邮箱,图片地址,手机号码等,这个时候想匹配或者查找符合某些规则的字符就可以使用正则表达式了
- 就是在复杂的字符串中取出我们想要的信息

### ②概念

- 正则表达式就是记录文本规则的代码

### ③特点

- 语法可读性差
- 正则表达式通行性很强,能够适用于很多编程语言

### ④样子

- 0\d{2}-\d{8}
- 这就是一个正则表达式, 表达的意思是匹配的是座机号码

## 2.re的模块介绍

### ①格式

```python
# 导入正则模块
import re
# 用match方法进行匹配操作
# match会从开头进行匹配,开头没有匹配成功就不再匹配
res = re.match(正则表达式, 匹配的字符串数)
# 上一步匹配到数据的话,适用group方法提取数据
res.group()
```

### ②re模块的简单使用

```python
import re
a = 'zhangsan@163.com'
b = 'lisi@qq.com'
c = '010-2564252'
d = 'http://www.baidu.com'
e = '<a>百度</a>'

res = re.match('z', a)
print(res.group())  # z
res1 = re.match('a', a)
try:
    print(res1.group())  # 报错
except:
    print('未匹配到数据')  # 未匹配到数据
```

# 四.正则表达式的使用

## 1.匹配单个字符

![1647785688100](/1647785688100.png)

```python
import re
a = 'zhangsan@163.com'
b = 'lisi@qq.com'
c = '010-2564252'
d = 'http://www.baidu.com'
e = '<a>百度</a>'
f = 'hello world'

...
try:
    print(res.group())
except:
    print('未匹配到数据')
```

### ①.符号表达式：表示任意字符

```python
# res = re.match('.....', a)  # zhang
# res = re.match('..', e)  # <a
```

### ②[]范围指定

```python
# res = re.match('[a-z][a-z][a-z][a-z]', b)  # lisi
# res = re.match('[a-z0-9][a-z0-9][a-z0-9]', c)  # 010
# res = re.match('[a-z0-9][a-z0-9][a-z0-9][a-z0-9]', c)  # 未匹配到数据
```

### ③\d 匹配数字 \D 匹配非数字

```python
# res = re.match('\d\d\d', a)  # 未匹配到数据
# res = re.match('\d\d\d', c)  # 010
# res = re.match('\D\D\D', e)  # <a>
# res = re.match('\d\d\d\D\d\d\d\d\d\d\d', c)  # 010-2564252
# res = re.match('\d{3}\D\d{7}', c)  # 010-2564252
```

### ④\s 匹配空格 \S 匹配非空格

```python
# res = re.match('\S{5}\s\S{5}', f)  # hello world
```

### ⑤\w 匹配字母和数字 \W 非字母非数字非汉字

```python
res = re.match('\w{4}\W\w{2}\W\w{3}', b)  # lisi@qq.com
```

## 2.匹配多个字符

![1647785717080](/1647785717080.png)

### ①* 匹配前字符出现0/n次

```python
# res = re.match('.*', a)  # zhangsan@163.com
# res = re.match('\d*', a)  # 空数据不报错
res = re.match('\d*', c)  # 010
```

### ②+匹配前字符出现1/n次

```python
# res = re.match('\d+', c)  # 010
# res = re.match('\w+', b)  # lisi
# res = re.match('\d+', b)  # 未匹配到数据
```

### ③?匹配前字符出现1or0次

```python
# res = re.match('\d?', a)  # 空数据
# res = re.match('\w?', a)  # 空数据
```

### ④{m}{m,n}匹配前字符出现m次m至n次

```python
res = re.match('.{11}', a)  # zhangsan@16
res = re.match('.{11,20}', a)  # zhangsan@163.com
```