---
typora-root-url: assets
---

# 第二章 多任务编程--线程

# 一.线程

## 1.线程的概念

## 2.线程和进程的区别

- 进程是操作系统进行**资源分配的基本单位**(最小单位)

- 线程是**CPU调度执行的基本单位**(最小单位)
  - 线程来执行代码逻辑
  - 代码执行的最小单位就是线程
- 每个程序最少有一个进程 , 每个进程中最少有一个线程(主线程)
  - 进程  : 只是给程序分配了空间 , 将代码存储在空间里
  - 线程  : 执行代码 
- 多任务方法:
  - 多进程 : 创建多个空间 , 每个空间都一个主线程 , 执行相同的代码
  - 多线程 : 只有一个空间 , 创建多个线程去执行同一份代码(消费资源少一点)

# 二.多线程的使用

## 1.导入模块

```python
# 导入线程模块
import threading
```

## 2.Thread方法介绍

```python
# 创建线程
# group = None使用默认,
# target = None指定函数方法,
# name = None指定线程名称,
# args = (), kwargs = None,传参
# daemon = None设置守护线程
```
## 3.线程的基本使用

```python
# 导入线程模块
import threading


def func():
    print('线程使用')


if __name__ == '__main__':
    # 创建线程
    t1 = threading.Thread(target=func)
    t2 = threading.Thread(target=func)
    # 启动运行线程
    t1.start()
    t2.start()
    
# 线程使用
# 线程使用
```

## 4.线程的传参 

> 通过传参,看出线程的执行顺序是无序的

```python
import threading


def func(data):
    print('线程使用')
    print(f'参数数据:{data}')


if __name__ == '__main__':

    t1 = threading.Thread(target=func, args=('Python',))
    t2 = threading.Thread(target=func, kwargs={'data': 'itcase'})
    # 启动运行线程
    t1.start()
    t2.start()
    
    
# 线程使用
# 参数数据:Python
# 线程使用
# 参数数据:itcase
```

## 5.线程的指定名称

```python
import threading


def func(data):
    print('线程使用')
    print(f'参数数据:{data}')
    print('线程名称', threading.current_thread().name)


if __name__ == '__main__':

    t1 = threading.Thread(target=func, args=('Python',), name='t1')
    t2 = threading.Thread(target=func, kwargs={'data': 'itcase'}, name='t2')
    # 启动运行线程
    t1.start()
    t2.start()
    
 '''线程使用
参数数据:Python
线程名称 t1
线程使用
参数数据:itcase
线程名称 t2
'''
   
```

## 6.线程的注意点

### ①线程之间执行是无序的

```python
import threading


def func():
    print('线程关系\n')
    print('子线程:', threading.current_thread().name)


if __name__ == '__main__':
    # 创建线程
    t1 = threading.Thread(target=func, name='t1')
    t2 = threading.Thread(target=func, name='t2')

    t1.start()
    t2.start()
    print('主线程')
    
    
    '''
    线程关系

子线程: t1
线程关系
主线程

子线程: t2'''
```

### ②主线程会等待所有的子线程执行结束再结束

- 若要使主线程序结束后 ,自动结束子线程?
  - 使用守护线程daemon
  - 线程对象.setDaemon(True)

```python
import threading


def func():
    print('线程关系\n')
    print('子线程:', threading.current_thread().name)


if __name__ == '__main__':
    # 创建线程
    t1 = threading.Thread(target=func, name='t1', daemon=True)
    t2 = threading.Thread(target=func, name='t2', daemon=True)

    t1.start()
    t2.start()
    print('主线程')
    
    '''线程关系

子线程: t1
线程关系
主线程'''
```

### ③线程之间共享全局变量

- 因为所有线程都是在同一个内存空间的
- 再同一个空间全局变量可以共享

```python
import threading

data_list = []


def write_data():
    for i in range(0, 10):
        data_list.append(i)
    print('write_data方法写入的数据为:', data_list)


def read_data():
    print('read_data方法读取的数据为:', data_list)


if __name__ == '__main__':
    p1 = threading.Thread(target=write_data)
    p2 = threading.Thread(target=read_data)

    p1.start()
    p2.start()
    print('主线程', data_list)
    
    '''
write_data方法写入的数据为: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
read_data方法读取的数据为: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
主线程 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    '''
```

### ④线程之间共享全局变量数据出现问题

- 可能出现脏数据
  - 输出错位问题的原因是 :　输出程序的终端资源被抢占 , 不是程序错误造成的
- 尽可能在多线程的情况下 , 使用独立变量
- 解决的方法:线程同步(join)
  - 保证同一时刻只能有一个线程去操作全局变量
  - 同步: 协调同步,按照预定的先后次序进行运行
  - 互斥锁

```python
import threading

date = 0


def func1():
    global date
    for i in range(100000):
        date += 1

    print(f'函数1的累加结果:{date}')


def func2():
    global date
    for i in range(100000):
        date += 1

    print(f'函数2的累加结果:{date}')


if __name__ == '__main__':
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()
    t2.start()
    print(f'主线程的结果展示:{date}')
    
    '''
函数1的累加结果:100000
主线程的结果展示:181680
函数2的累加结果:200000
'''
```

![1647237864603](/1647237864603.png)

#### Ⅰ互斥锁

互斥锁:对共享数据进行锁定 ,保证同一时刻只能有一个线程去操作 ,保证不会出现错误问题

- 互斥锁当多个线程一起去抢 , 抢到锁的线程先执行 ,没有抢到锁的线程需要等待 ,等互斥锁释放后 , 其他等待的线程再去抢这个锁
- 缺点:
  - 使用互斥锁会影响代码的执行效率 ,多任务改成了单任务执行
  - 互斥锁如果没有使用好 ,可能出现死锁的情况

```python
import threading

date = 0
# 创建互斥锁
lock = threading.Lock()

def func1():
    # 上锁
    lock.acquire()
    global date
    for i in range(100000):
        date += 1

    print(f'函数1的累加结果:{date}')
    # 释放锁
    lock.release()

def func2():
    # 上锁
    lock.acquire()
    global date
    for i in range(100000):
        date += 1

    print(f'函数2的累加结果:{date}')
    # 释放锁
    lock.release()

if __name__ == '__main__':
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()
    t2.start()
    # 上锁
    lock.acquire()
    print(f'主线程的结果展示:{date}')
    # 释放锁
    lock.release()
    
'''
函数1的累加结果:100000
函数2的累加结果:200000
主线程的结果展示:200000
'''
```

#### Ⅱ死锁

- 一直等待对方释放锁的情景就是死锁
  - 结果:应用程序停止响应 ,不能再处理其他任务
  - 解决:在合适的地方释放锁

![1647248682067](/1647248682067.png)

# 三.进程和线程区别

## 1.关系对比

线程是依附在进程空间

一个进程里至少有一个线程的存在 ,来执行代码

## 2.区别对比

- 进程之间不共享全局变量
  - 可以通过文件介质来共享
- 线程之间默认共享全局变量
  - 要注意资源竞争问题 , 解决问题:线程同步(join)
- 创建进程的资源开销要比创建线程的资源开销大
- 进程是操作系统资源分配的基本单位 ,线程是CPU调度的基本单位
- 线程不能独立执行 ,必须依存在进程中
- 多进程开发比单进程多线程开发稳定性强
  - 数据全局变量的方面
  - 线程依赖进程 ,当进程出问题 ,线程也会出问题

## 3.优缺点对比

- 进程优缺点
  - 优点:可以用多核
  - 缺点:资源开销大
- 线程的优缺点
  - 优点:资源开销小
  - 缺点:不能使用多核 , 数据问题















































