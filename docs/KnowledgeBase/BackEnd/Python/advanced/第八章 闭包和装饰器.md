---
typora-root-url: assets

---

# 第八章 闭包和装饰器



#  一.闭包

## 1.闭包的介绍

> 我们前面已经学过了函数 , 我们知道当函数调用完 , 函数内定义的变量都销毁了 ,但是我们有时候需要保存函数内的这个变量.每次在这个变量的基础上完成一系列的操作
>
> 比如:每次在这个变量的基础上和其他数字进行求和计算,那么怎么办呢?

- 闭包:在函数嵌套的前提下 , 内部函数使用了外部函数的变量 , 并且外部函数返回了内部函数,我们把**使用外部函数变量的内部函数称为闭包**

## 2.闭包的构成条件

闭包形成的条件

- 在函数嵌套的前提下
- 内部函数使用了外部函数的变量
- 外部函数返回了内部函数

## 3.简单闭包的实例代码

```python
def func_out(n1):
    def func_inner(n2):
        result = n1 + n2
        print('结果是:', result)
    return func_inner
```

# 二.闭包的使用

## 1.简单使用

**注意**:返回的时候一定不能加() , 不然就是调用了

```python
# 使用原有的知识
def func_1():
    a = 10
    return a


def func_2(a):
    b = 20
    a + b
    print(a + b)


# data = func_1()
# func_2(data)  # 30


# 同样的功能 ,使用闭包实现
def func_3():
    c = 10
    print('func_3被调用')

    def func_4():
        d = 30
        print(c + d)

    # 需要将内部定义的函数在外部函数进行返回
    # 不能加() , 加了就是调用了 
    return func_4
    

# 调用的是func_3() , 打印出来的是func_4结果
f = func_3()  # func_3被调用
print(f)  # 返回的是一个函数
f()  # 40 加括号就是调用
```

## 2.闭包参数

### ①参数可接受值种类

- 普通变量

- 函数名

  - > def func(a):
    > 	a()

  - > func(函数名)

- 对象

- ```python
  class A():
      def func5(self):
          self.name = 'Tom'
          print('func5执行')
          
  a_obj = A()  # 这就是一个对象
  
  def func(obj):
  	obj.func5()
      obj.name = 'Mary'
      
      
  func(a_obj)
  ```

### ②参数使用

- 参数可以实现对话
- 传入不同的参数可以实现: 得出不同的返回结果

```python
def out(num1):
    # 业务
    def inner(num2):
        # 业务
        print(num1 + num2)

    return inner

f = out(5)
f(2)  # 7
```

```python
def func1(name):
    def func2(action):
        print(name + action)

    return func2

f = func1('Mary')
f('在玩滑板')  # Mary在玩滑板
f = func1('Mike')
f('在唱歌')  # Mike在唱歌
```

# 三.装饰器

## 1.装饰器的定义

- 装饰器: 在不改变原有函数业务代码的基础上 , 给函数增加额外功能的函数 , 它本质上就是一个闭包函数
- 装饰器的本质就是将我们的被装饰函数 , 当作参数传递到闭包函数中

## 2.装饰器的功能特点

- 不修改原有函数的源代码
- 不修改已有函数的调用方式
- 给已有函数增加额外的功能

# 四.装饰器的使用

> 在通常业务中 , 一般开发好的代码不允许被更改 , 因此向再增加功能等业务 , 只能使用闭包函数 , 也就是装饰器
>
> 装饰器只不过将闭包接受的参数换为函数了

## 1.装饰器两种格式

- 闭包函数外部接受参数

  - @func

  - > f = func1(func)
    >
    > f()

- 闭包函数内部接受参数

  - @func()

  - > f = func3()
    >
    > f(show_user)

## 2.代码实现--最基本装饰器

```python
# 定义一个闭包函数完成登陆验证
# ①函数外部接受参数
def func1(func):
    def func2():
        # func参数,接受一个函数(被装饰的函数)
        print('登陆验证成功')
        func()

    return func2


# ②函数内部接受参数
def func3(func):
    def func4():
        # func参数,接受一个函数(被装饰的函数)
        print('登陆验证成功')
        func()

    return func4

# 内部
# 方法①
# f = func3()
# f(show_user)
# 方法②:装饰器语法格式(内部)@func3()
# 外部
# ①
# f = func1(func)
# f()
# ②
@func1
def show_user():
    # 增加登陆验证逻辑
    print('展示用户信息')


def func5():
    show_user()


func5()
# 登陆验证成功
# 展示用户信息
```

## 3.装饰器--带有参数的函数

### ①方法

- 内部函数或者外部函数接受(被装饰函数 + 被装饰函数的参数)
- 外部函数接受(被装饰的函数) + 内部函数接受(被装饰函数的参数)

### ②代码实现

```python
# 内部函数接受所有的参数
def out():
    def inner(func, num1, num2):
        print('正在计算...')
        func(num1, num2)
    return inner

# 加法函数
def add1(num1, num2):
    data = num1 + num2
    print(data)

f = out()
f(add1, 1, 2)
# 正在计算...
# 3
```

```python
# 内部函数接受被装饰函数的参数
# 外部接受被装饰函数
def out(func):
    def inner(num1, num2):
        print('正在计算...')
        func(num1, num2)

    return inner


# 加法函数
@out
def add1(num1, num2):
    data = num1 + num2
    print(data)


add1(1, 2)
# ②
# f = out(add1)
# f(1, 2)
# 正在计算...
# 3
```

### ③闭包当中也可以使用不定长参数

- 对字典或者元祖列表进行取值
- 进一步利用下标取值

> 在实际工作中使用闭包的时候一般都是出现了漏洞或者需要添加已知的功能
>
> 因此闭包里面不管函数的参数个数,还是参数的使用都已知的主动行为代码 , 不是未知的
>
> 原有功能一般是已知的

```python
# 一个乘法函数 , 有三个参数 , 因为不确定客户会传入什么类型的值,因此需要解析参数
# 也就是定义一个装饰器,来将参数转化为乘法函数可以使用的
# 这里就使用到了不定长参数*args(接受元组列表),**kwargs(接受字典)
# 定义闭包函数
def out(f):
    def inner(*args, **kwargs):
        print(args)
        print(kwargs['num1'], kwargs['num2'], kwargs['num3'])  # 2 5 7
        f(kwargs['num1'], kwargs['num2'], kwargs['num3'])  # 70
    # 如果不拆包那么字典就会传入到*args中,就需要使用下面来解析数据
    # f(args[0]['num1'], args[0]['num2'], args[0]['num3'])
    return inner


# 乘法函数
@out
def mult(num1, num2, num3):
    data = num1 * num2 * num3
    print(data)


# 在知道传入的参数不是int值而是字典的情况下
# 在不改变原来函数的前提下,定义装饰器,解析函数
# 这里如果使用拆包解压 , 则闭包里的操作会简单一些
data1 = {'num1': 2, 'num2': 5, 'num3': 7}
# 拆包解压 , 字典就会传入**kwargs中
mult(**data1)
# ()
# {'num1': 2, 'num2': 5, 'num3': 7}
```

## 4.装饰器--带有返回值的函数

- 当被装饰函数有返回值时
  - 返回值需要进行两次导出--中间再传递给装饰器内部的返回值--最后输出
- 当装饰器内部有返回值时
  - 只需要最后调用函数时候导出,输出

```python
# 被修饰函数带有返回值的
def out(f):
    def inner(*args, **kwargs):
        print('用户登陆成功')
        res = f(*args, **kwargs)
        return res
    return inner

@out
def show_data():
    print('显示用户信息')
    return '用户信息显示成功'

res = show_data()
print(res)
# 用户登陆成功
# 显示用户信息
# 用户信息显示成功
```

```python
# 被修饰函数带有返回值的
def out(f):
    def inner(*args, **kwargs):
        print('用户登陆成功')
        f(*args, **kwargs)
        return '用户登陆验证完成'
    return inner

@out
def show_data():
    print('显示用户信息')

res = show_data()
print(res)
# 用户登陆成功
# 显示用户信息
# 用户登陆验证完成
```

# 五.通用装饰器

## 1.通用装饰器的定义

- 通用装饰器--就是多个方法都会用到的装饰器
- 通用装饰器--需要使用不定长参数实现

## 2.通用装饰器的使用场景

### ①登陆验证操作

```python
# 通用装饰器 , 借助不定长参数实现
# 最基本的通用装饰器
def out1(f):
    def inner1():
        print('用户登陆成功')
        f()
    return inner1
# 借助不定长参数的通用装饰器
def out(f):
    def inner(*args, **kwargs):
        print('用户登陆成功')
        f(*args, **kwargs)
    return inner
@out
def show_data():
    print('显示用户信息')
show_data()
# 用户登陆成功
# 显示用户信息
@out
def buy(price):
    print('商品购买')
    print(f'商品价格为{price}')
buy(100)
# 用户登陆成功
# 商品购买
# 商品价格为100
```

### ②日志操作

```python
# 函数产生错误,想把错误写入到日志文件中
def out(f):
    def inner(*args, **kwargs):
        print('日志写入')
        # 被装饰函数可能出错,一旦出错就捕获异常信息
        try:
            f(*args, **kwargs)
        except Exception as e:
            print(e.args[0])
            file = open('a.log', 'a')
            file.write(e.args[0])
    return inner

@out
def errfunc():
    1/0
errfunc()
# a.log
# division by zero
```