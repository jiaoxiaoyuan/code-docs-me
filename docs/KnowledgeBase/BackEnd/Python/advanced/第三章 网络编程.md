---
typora-root-url: assets
---

# 第三章 网络编程

# 一.IP地址的介绍

## 1.IP地址的概念

IP地址: 标识网络中设备的一个地址 , 好比现实生活中的家庭地址

![1647313490543](/1647313490543.png)

## 2.IP地址的表现形式

- ip地址
  - IPv4
    - 目前使用的IP地址
    - 是由点分制十进制组成
  - IPv6
    - 未来使用使用的IP地址
    - 是由冒号十六进制组成

![1647314132398](/1647314132398.png)

## 3.IP地址的作用

- IP地址的作用是表示网络中唯一的一台设备的 , 也就是说通过IP地址能够找到网络中的某台设备

## 4.查看IP地址

Windows : ipconfig

linux : ifconfig

mac OS : ifconfig

## 5.检查网络是否正常

能否正常使用ping命令

- ping www.baidu.com 检查是否能上公网
- ping 当前局域网 检查是否在同一个局域网内
- ping 192.168.137.1(本机) 检查本地网卡是否正常

![1647314422014](/1647314422014.png)

# 二.端口和端口号的介绍

## 1.问题思考

> 不同电脑上的QQ之间进行数据通信 ,它是如何保证把数据给QQ而不是其他软件呢?
>
> 其实,每运行一个网络程序都会有一个端口 ,想要给对应的程序发送数据 , 找到对应的端口即可

![1647314643807](/1647314643807.png)

## 2.什么是端口

端口是传输数据的通道 ,是数据传输的必经之路

> 怎么找到对应的端口?
>
> 每个端口都会有一个对应的端口号

## 3.什么端口号

操作系统为了统一管理这么多端口 ,就对端口进行了编号,端口号其实就是一个数字

> 那么QQ之间进行数据通信的流程是这样的
>
> 通过IP地址找到对应的设备 , 通过端口号找到对应的端口 ,通过端口传输数据给应用程序.

![1647314729590](/1647314729590.png)

## 4.端口和端口号的关系

端口号可以标识唯一的一个端口

## 5.端口号的分类

- 知名端口号
  - 众所周知的端口号 ,范围从0-1023
  - 这些端口号一般固定分配给一些服务 , 比如:
    - 21端口 : FTP服务(文件传输协议)
    - 25端口:SMTP服务(简单邮件传输)
    - 80端口 : 分配给HTTP服务
- 动态端口号
  - 程序员开发应用程序使用的端口号 , 范围从1024-65535
  - 如果程序员开发的程序没有设置端口号 , 操作系统会在动态端口号这个返回内随机生成一个给开发的应用程序使用
  - 当运行一个程序默认会有一个端口号 , 当这个程序退出时 ,所占用的这个端口号就会被释放

# 三.TCP的介绍

## 1.网络应用程序之间的通信

> 数据不能随便发送 ,在发送之前还需要选择一个对应的传输协议 , 保证程序之间按照指定的传输规则进行数据的通信

## 2.TCP的概念

TCP(Transmission Control Protocol传输控制协议) , 它是一种面向连接的, 可靠的 , 基于字节流的传输层通信协议

常用于对数据进行准确无误的传输 : 比如文件下载 ,浏览器上网

- TCP通信步骤
  - 创建连接
  - 传输数据
  - 关闭连接

## 3.TCP的特点

- 面向连接
  - 通信双方必须先建立连接 , 才能开始传输数据 , 数据传输完成后 ,双方必须断开此连接 ,以释放系统资源
- 可靠传输
  - TCP采用发送应答机制
  - 超时重传
  - 错误校验
  - 流量控制和阻塞管理

# 四.socket的介绍

## 1.问题思考

> 到目前我们学了IP地址,端口号,TCP传输协议
>
> 1.为了保证数据的完整性和可靠性----TCP传输数据
>
> 2.为了能够找到对应设备--IP地址
>
> 3.为了区别某个端口的应用程序接收数据----端口号
>
> 4.那么通信数据是如何完成传输的?
>
> socket

## 2.socket的概念

socket(简称 套接字) 是进程之间通信的一个工具

![1647325287779](/1647325287779.png)

## 3.socket的作用

负责进程之间的网络数据传输---数据的搬运工

- 网路编程中Python封装的一个模块

## 4.socket使用场景

只要根网络相关的应用程序或者软件 ,都使用到了socket

# 五.TCP网络应用程序开发流程

## 1.TCP网络应用程序开发流程

TCP网络应用程序开发分为:

- TCP客户端程序开发
  - 客户端 : 指运行在用户设备上的程序
- TCP服务端程序开发
  - 服务端:运行在服务器设备上的程序 , 专门为客户端提供数据服务

![1647325638203](/1647325638203.png)

## 2.TCP客户端程序开发流程

> 浏览器就是客户端

- 创建客户端套接字对象
- 和服务端套接字建立连接
- 发送数据
  - 主动发起建立连接请求的是客户端程序
- 接受数据
- 关闭客户端套接字

## 3.TCP服务端程序开发流程

> 后端开发主要指服务端开发

- 创建服务端套接字对象
- 绑定端口号
- 设置监听
- 等待接受客户端的连接请求
  - 等待接受连接请求的是服务端程序
- 接收数据
- 发送数据
- 关闭套接字

# 六.网络调试助手的使用

![1647330117411](/1647330117411.png)

# 七.TCP-客户端-程序开发

> 生活中的客户端:浏览器 ,QQ

## 1.补充知识(bytes与str相互转化)

- 数据的定义:
  - 字符串: 'hello'
  - 字节类型 :b'hello'

- encode
  - 将字符串类型数据转化为字节类型数据
- decode
  - 将字节类型数据转化为字符串类型数据

```python
str1 = 'hello'
print(type(str1))  # <class 'str'>
print(str1.encode())  # b'hello'
print(type(str1.encode()))  # <class 'bytes'>

bytes1 = b'world'
print(type(bytes1))  # <class 'bytes'>
print(type(bytes1.decode()))  # <class 'str'>
```

## 2.开发程序

```python
# 导入网络开发工具
import socket

# 1.创建socket对象
# 1.1socket.AF_INET 指定IP地址为IPv4
# 1.2socket.SOCK_STREAM 指定通讯方式为TCP协议
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 2.连接服务器
client.connect(('192.168.137.1', 8002))
# 3.发送数据(bytes类型)
# 3.1发送的数据若为中文,防止乱码 ,使用utf-8或者gbk解析格式
date = '你好'
client.send(date.encode(encoding='gbk'))
# 4.接受数据(bytes类型)
# 4.1需要指定每次接受数据的大小
recv_bytes_data = client.recv(1024)
# 4.2将字节类型转化为字符串
recv_str_data = recv_bytes_data.decode(encoding='gbk')
# 4.3如果服务器端一直不返回数据给客户端 , 就会一直等待
print(recv_str_data)
# 5.关闭客户端
client.close()

# hello client
```

![1647333436909](/1647333436909.png)

## 3.使用到的方法

- socket  创建客户端连接对象
- connect 连接服务器(指定IP和端口)
- send 发送数据到服务器
- recv 接受服务器返回的数据
- close 关闭客户端
- encode 转化为字节类型
- decode 字节类型转化为字符串

# 八.TCP-服务端-程序开发

> 后端开发框架工具
>
> - Python : Flask , Djiango
> - Java : Spring Boot
>
> 他们把相应的模块都封装好了 ,方便程序员开发

## 1.开发程序

![1647347203990](/1647347203990.png)

一次交互,最后客户端关闭 ,交互结束

### ①客户端

```python
# 导入网络开发工具
import socket

# 1.创建socket对象
# 1.1socket.AF_INET 指定IP地址为IPv4
# 1.2socket.SOCK_STREAM 指定通讯方式为TCP协议
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 2.连接服务器
client.connect(('192.168.137.1', 8003))
# 3.发送数据(bytes类型)
# 3.1发送的数据若为中文,防止乱码 ,使用utf-8或者gbk解析格式
date = 'hello server'
client.send(date.encode())
# 4.接受数据(bytes类型)
# 4.1需要指定每次接受数据的大小
recv_bytes_data = client.recv(1024)
# 4.2将字节类型转化为字符串
recv_str_data = recv_bytes_data.decode()
# 4.3如果服务器端一直不返回数据给客户端 , 就会一直等待
print(recv_str_data)
# 5.关闭客户端
client.close()

# hello client
```

### ②服务器端

```python
# 导入网络开发工具
import socket

# 1.创建服务端连接对象
# 1.1socket.AF_INET 指定IP地址为IPv4
# 1.2socket.SOCK_STREAM 指定通讯方式为TCP协议
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 2.绑定ip和端口 ,方便后续接听是否有客户端请求服务端的ip和端口
server.bind(('192.168.137.1', 8003))
# 3.指定监听的数量(多任务里怎么解决并发问题)(一般最大监听同时125)
# 3.1一般监听5
server.listen(5)
print('服务端启动中...')
# 4.等待客户端连接(会阻塞)
# 4.1sock返回:代表客户端的各种数据
# 4.2addr返回客户端的IP地址和端口信息
client_socket, addr = server.accept()
print('客户端scoket', client_socket)
print('客户端地址', addr)
# 5.接受客户端传递的数据
recv_date = client_socket.recv(1024)
print(recv_date)
# 6.返回数据给客户端
date = 'hello client'
client_socket.send(date.encode())
# 7.关闭服务端
server.close()

'''
服务端启动中...
客户端scoket <socket.socket fd=540, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.137.1', 8003), raddr=('192.168.137.1', 63449)>
客户端地址 ('192.168.137.1', 63449)
b'hello server'
'''
```

## 2.使用的方法

- socket 创建服务端连接对象
- bind 服务端绑定设备的的IP和端口
- listen 指定监听客户端请求数量
- accept 等待客户端连接
- recv 接受客户端的数据
- send  返回数据给客户端
- close 关闭服务端

# 九.案例-多任务版TCP服务端程序开发

## 1.需求

> - 在实际开发中,服务端是需要持续运行的 ,怎么解决?
>   - 把服务端开发步骤中第4-7步骤放到死循环里面
> - 实际上 , 客户端请求一次就关闭客户端 , 再请求的时候 ,看作是新的客户端请求
> - 那么 ,想让服务端一直能接收返回数据 ,而且又能一直连接到新的客户端,怎么解决?
>   - 两个循环码? 不对
>   - 对于数据处理 , 交给一个线程处理 , 不妨碍主线程的连接新的客户端

![1647347862721](/1647347862721.png)

## 2.示例代码

```python
# 导入网络开发工具
import socket
import threading
def client_data(client_socket):
    while True:
        # 5.接受客户端传递的数据
        recv_date = client_socket.recv(1024)
        # 6.返回数据给客户端
        date = 'hello client'
        client_socket.send(date.encode())

# 1.创建服务端连接对象
# 1.1socket.AF_INET 指定IP地址为IPv4
# 1.2socket.SOCK_STREAM 指定通讯方式为TCP协议
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 2.绑定ip和端口 ,方便后续接听是否有客户端请求服务端的ip和端口
server.bind(('192.168.137.1', 8003))
# 3.指定监听的数量(多任务里怎么解决并发问题)(一般最大监听同时125)
# 3.1一般监听5
server.listen(5)
print('服务端启动中...')
# 4.等待客户端连接(会阻塞)
# 4.1sock返回:代表客户端的各种数据
# 4.2addr返回客户端的IP地址和端口信息
while True:

    client_socket, addr = server.accept()
    print('客户端scoket', client_socket)
    print('客户端地址', addr)
    # 创建线程 ,处理每一个客户端的请求数据
    t = threading.Thread(target=client_data, asgs=(client_socket,))
    t.start()
# 7.关闭服务端
server.close()
```

# 十.TCP应用程序的注意点

- 当TCP客户端程序想要和TCP服务端程序进行通信的时候 , 必须先建立连接
- TCP客户端程序一般不需要绑定端口号 ,因为是客户端是主动发起连接的
- TCP服务端程序必须绑定端口号 , 否则客户端找不到这个TCP服务端程序
- listen后的套接字是被动套接字 ,只负责接受新的客户端的请求连接 , 不能收发消息
- 当TCP客户端程序和TCP服务端程序连接成功后 ,TCP服务端程序会产生一个新的套接字,收发客户端消息使用该套接字
- 关闭accept返回的套接字意味着和这个客户端已经通信完毕
- 关闭listen后的套接字意味着服务端中的套接字关闭了 , 会导致新的客户端不能连接服务器 ,但之前已经连接成功的客户端还能正常通信
- 当客户端的套接字调用close后 ,服务器端的recv会解阻塞 , 返回的数据长度为0 ,服务端可以通过返回的数据长度判断客户端是否已经下线 ,反之服务器关闭套接字 , 客户端的recv也会解阻塞 , 返回的数据长度也为0

